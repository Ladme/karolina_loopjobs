#!/bin/bash -l

# Script for running individual Gromacs simulations on Karolina's GPU partition in loops.
# Author: Ladislav Bartos

# @@@@@@@@@@@@@@@@@@@@@@@@@@
# @     SLURM OPTIONS      @
# @@@@@@@@@@@@@@@@@@@@@@@@@@

#SBATCH --job-name=loop_md
#SBATCH --account=[[ACCOUNT_ID]]
#SBATCH --time=24:00:00
#SBATCH --nodes=1
#SBATCH --ntasks=1
#SBATCH --cpus-per-task=8
#SBATCH --partition=qcpu
#SBATCH -e job-%j.err -o job-%j.out

# @@@@@@@@@@@@@@@@@@@@@@@@@@
# @     GROMACS OPTIONS    @
# @@@@@@@@@@@@@@@@@@@@@@@@@@

# name of the directory to be used for data storage
STORAGE_DIR="storage"

# GROMACS FILES TO USE
MDP="umbrella.mdp"
GRO="system.gro"
CPT=""  # leave empty if not needed
TOP="system.top"
NDX="index.ndx"
REF="reference.gro"  # leave empty if not needed
MAXWARN="1"

# gromacs version
GMX_VERSION="GROMACS/2021.4-fosscuda-2020b-PLUMED-2.7.3"

# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

# loading modules
ml ${GMX_VERSION} || exit 1

# get the current cycle of the loop job
if [ -f finished_cycle ]; then
    CYCLE=$(( $(cat finished_cycle) + 1 ))
else
    CYCLE=1
fi

# get the next cycle of the loop job
NEXT=$(( $CYCLE + 1 ))

CYCLE_FMT=$(printf "%04d" ${CYCLE})
NEXT_FMT=$(printf "%04d" ${NEXT})

# if this is the first cycle, run grompp for each window
if [ $CYCLE -eq 1 ]; then
    # prepare STORAGE_DIR
    if [ ! -d ${STORAGE_DIR} ]; then mkdir ${STORAGE_DIR}; fi
    
    # optional checkpoint and reference files for grompp
    if [ ! -z ${REF} ]; then FULL_REF="-r ${REF}"; fi
    if [ ! -z ${CPT} ]; then FULL_CPT="-t ${CPT}"; fi
    
    gmx grompp -f ${MDP} -c ${GRO} ${FULL_CPT} -p ${TOP} -n ${NDX} ${FULL_REF} -o ${STORAGE_DIR}/md${CYCLE_FMT}.tpr -maxwarn ${MAXWARN} || exit 1
    CPI_COMMAND=""
else
    CPI_COMMAND="-cpi ${STORAGE_DIR}/md${CYCLE_FMT}.cpt"
fi

# run the gromacs simulation
srun -n 1 gmx_mpi mdrun -ntomp $SLURM_CPUS_PER_TASK -v -deffnm ${STORAGE_DIR}/md${CYCLE_FMT} ${CPI_COMMAND} -cpo ${STORAGE_DIR}/md${NEXT_FMT} -noappend || exit 1 

# extend the simulation
EXTEND=`awk 'BEGIN {dt = 0.001; nsteps = 0} /nsteps/ {nsteps = $3} /dt/ {dt = $3} END {ext = nsteps * dt; if (!ext) {exit 2} else {print ext}}' ${MDP}`
if [ $? -ne 0 ]; then exit 1; fi
gmx convert-tpr -s ${STORAGE_DIR}/md${CYCLE_FMT}.tpr -extend ${EXTEND} -o ${STORAGE_DIR}/md${NEXT_FMT}.tpr -quiet || exit 1

# rename the output files
for FILE_SUFFIX in .gro .edr .log _pullf.xvg _pullx.xvg .xtc; do
    OLD=${STORAGE_DIR}/md${CYCLE_FMT}.part${CYCLE_FMT}${FILE_SUFFIX}
    if [ -f $OLD ]; then
        mv $OLD ${STORAGE_DIR}/md${CYCLE_FMT}${FILE_SUFFIX}
    fi
done

# remove the sub_job file generated by loop_sub
rm -f sub_job_$(echo $SLURM_JOB_ID | tr -dc '0-9')

# save the current cycle of the loop job
# (has to be done at the end of the script execution)
echo $CYCLE > finished_cycle

exit 0
